import {
    Group, 
    Mesh, 
    // SphereGeometry, 
    MeshStandardMaterial,
    Vector3} from 'three';
import { ConvexGeometry } from '../node_modules/three/examples/jsm/geometries/ConvexGeometry.js';

// extend the group class to cloud because we want groups of clouds, not just single clouds
export class Cloud extends Group {
    constructor(options = {}) {
        // parents
        super();

        // constants, geometry, mats
        const {
            spheresPerCloud = 500,
            sphereRadius = 1,
            sphereScaleRange = [0.5, 1.5], // random scale multiplier
            spread = 4, // how far each sphere can stray from the origin
            jitter = 0.2 // max random displacement along normals
        } = options;
        // const segments = [100, 100];
        // const geometry = new SphereGeometry(sphereRadius, segments[0], segments[1]);
        const material = new MeshStandardMaterial({
            color: 0xffffff,
            flatShading: false,
            transparent: true,
            opacity: 0.8
        });

        //     // set up/assign vals to each sphere generated
        // for (let i = 0; i < spheresPerCloud; i++) {
        //     // random scale within acceptable scale range
        //     const scale = Math.random() * (sphereScaleRange[1] - sphereScaleRange[0]) + sphereScaleRange[0];

        //     const mesh = new Mesh(geometry, material);
        //     mesh.castShadow = true;
        //     mesh.receiveShadow = true;

        //     // random position within acceptable spread range
        //     mesh.position.set(
        //         (Math.random() - 0.5) * spread,
        //         (Math.random() - 0.5) * spread * 0.5,
        //         (Math.random() - 0.5) * spread
        //     );
        //     mesh.scale.set(scale, scale * 0.75, scale);

        //     // add cloud sphere to group
        //     this.add(mesh);
        // }

        const points = [];
        for (let i = 0; i < spheresPerCloud; i++) {
            const scale = Math.random() * (sphereScaleRange[1] - sphereScaleRange[0]) + sphereScaleRange[0];
            points.push(new Vector3(
                (Math.random() - 0.5) * spread,
                (Math.random() - 0.5) * spread * 0.5,
                (Math.random() - 0.5) * spread
            ).multiplyScalar(scale));
        }

        const hullGeo = new ConvexGeometry(points);
        hullGeo.computeVertexNormals();

        if (jitter > 0) {
            const pos = hullGeo.attributes.position;
            const norm = hullGeo.attributes.normal;
            for (let i = 0; i < pos.count; i++) {
                const d = (Math.random() * 2 - 1) * jitter;
                pos.setX(i, pos.getX(i) + norm.getX(i) * d);
                pos.setY(i, pos.getY(i) + norm.getY(i) * d);
                pos.setZ(i, pos.getZ(i) + norm.getZ(i) * d);
            }
            pos.needsUpdate = true;
            hullGeo.computeVertexNormals();
        }

        const cloudMesh = new Mesh(hullGeo, material);
        cloudMesh.castShadow = true;
        cloudMesh.receiveShadow = true;
        this.add(cloudMesh);
    };
}